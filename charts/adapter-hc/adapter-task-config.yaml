# HyperFleet Adapter - HostedCluster task configuration
# Equivalent of cls-hypershift-client: creates Namespace, pull-secret, signing-key,
# Certificate, and HostedCluster on the management cluster.
apiVersion: hyperfleet.redhat.com/v1alpha1
kind: AdapterTaskConfig
metadata:
  name: adapter-hc
  labels:
    hyperfleet.io/adapter-type: adapter-hc
    hyperfleet.io/component: adapter
spec:
  # ============================================================================
  # Phase 1: Parameter extraction
  # ============================================================================
  params:
    - name: "clusterId"
      source: "event.id"
      type: "string"
      required: true

    - name: "generation"
      source: "event.generation"
      type: "int"
      required: true

    - name: "namespace"
      source: "env.NAMESPACE"
      type: "string"
      required: true

    - name: "baseDomain"
      source: "env.HC_BASE_DOMAIN"
      type: "string"
      required: true
      description: "Base domain for hosted cluster DNS (e.g. hc-us-central1-nkcw.int.gcp-hcp.devshift.net)"

    - name: "releaseImage"
      source: "env.HC_RELEASE_IMAGE"
      type: "string"
      default: "quay.io/openshift-release-dev/ocp-release:4.20.0-x86_64"

    - name: "pullSecretStoreName"
      source: "env.PULL_SECRET_STORE_NAME"
      type: "string"
      default: "global-gcp-secret-manager"

    - name: "pullSecretGcpKey"
      source: "env.PULL_SECRET_GCP_KEY"
      type: "string"
      default: "openshift-pull-secret"

  # ============================================================================
  # Phase 2: Preconditions - fetch cluster details from HyperFleet API
  # ============================================================================
  preconditions:
    - name: "clusterDetails"
      apiCall:
        method: "GET"
        url: "/clusters/{{ .clusterId }}"
        timeout: 10s
        retryAttempts: 3
        retryBackoff: "exponential"
      capture:
        - name: "clusterName"
          field: "name"
        - name: "generation"
          field: "generation"
        - name: "createdBy"
          field: "created_by"
        - name: "infraID"
          expression: "spec.infraID"
        - name: "issuerURL"
          expression: "spec.?issuerURL.orValue('')"
        - name: "serviceAccountSigningKey"
          expression: "spec.?serviceAccountSigningKey.orValue('')"

        # GCP platform fields
        - name: "gcpProjectID"
          expression: "spec.platform.gcp.projectID"
        - name: "gcpRegion"
          expression: "spec.platform.gcp.region"
        - name: "gcpNetwork"
          expression: "spec.platform.gcp.network"
        - name: "gcpSubnet"
          expression: "spec.platform.gcp.subnet"
        - name: "gcpEndpointAccess"
          expression: "spec.platform.gcp.?endpointAccess.orValue('Private')"

        # WIF fields
        - name: "wifProjectNumber"
          expression: "spec.platform.gcp.workloadIdentity.projectNumber"
        - name: "wifPoolID"
          expression: "spec.platform.gcp.workloadIdentity.poolID"
        - name: "wifProviderID"
          expression: "spec.platform.gcp.workloadIdentity.providerID"
        - name: "nodePoolEmail"
          expression: "spec.platform.gcp.workloadIdentity.serviceAccountsRef.nodePoolEmail"
        - name: "controlPlaneEmail"
          expression: "spec.platform.gcp.workloadIdentity.serviceAccountsRef.controlPlaneEmail"
        - name: "cloudControllerEmail"
          expression: "spec.platform.gcp.workloadIdentity.serviceAccountsRef.cloudControllerEmail"
        - name: "storageEmail"
          expression: "spec.platform.gcp.workloadIdentity.serviceAccountsRef.storageEmail"

        # RFC4122 UUID for HostedCluster spec.clusterID
        - name: "hcClusterID"
          expression: "spec.?clusterID.orValue(id)"

        # Ready condition check
        - name: "readyConditionStatus"
          expression: |
            status.conditions.filter(c, c.type == "Ready").size() > 0
              ? status.conditions.filter(c, c.type == "Ready")[0].status
              : "False"

        # Compute slug from email (username part before @)
        - name: "slug"
          expression: "'user'"

      conditions:
        - field: "readyConditionStatus"
          operator: "equals"
          value: "False"

    - name: "validationCheck"
      expression: |
        readyConditionStatus == "False"

  # ============================================================================
  # Phase 3: Resources - create on management cluster
  # ============================================================================
  resources:
    # --- Resource 0: Namespace ---
    - name: "clusterNamespace"
      transport:
        client: "kubernetes"
      manifest:
        ref: "/etc/adapter/namespace.yaml"
      discovery:
        namespace: "*"
        bySelectors:
          labelSelector:
            hyperfleet.io/cluster-id: "{{ .clusterId }}"
            hyperfleet.io/resource-type: "namespace"

    # --- Resource 1: Pull Secret (ExternalSecret) ---
    - name: "pullSecret"
      transport:
        client: "kubernetes"
      manifest:
        ref: "/etc/adapter/pull-secret.yaml"
      discovery:
        namespace: "clusters-{{ .clusterId }}"
        bySelectors:
          labelSelector:
            hyperfleet.io/cluster-id: "{{ .clusterId }}"
            hyperfleet.io/resource-type: "pull-secret"

    # --- Resource 2: Signing Key Secret ---
    - name: "signingKeySecret"
      transport:
        client: "kubernetes"
      manifest:
        ref: "/etc/adapter/signing-key.yaml"
      discovery:
        namespace: "clusters-{{ .clusterId }}"
        bySelectors:
          labelSelector:
            hyperfleet.io/cluster-id: "{{ .clusterId }}"
            hyperfleet.io/resource-type: "signing-key"

    # --- Resource 3: API Server Certificate ---
    - name: "apiCertificate"
      transport:
        client: "kubernetes"
      manifest:
        ref: "/etc/adapter/certificate.yaml"
      discovery:
        namespace: "clusters-{{ .clusterId }}"
        bySelectors:
          labelSelector:
            hyperfleet.io/cluster-id: "{{ .clusterId }}"
            hyperfleet.io/resource-type: "certificate"

    # --- Resource 4: HostedCluster ---
    - name: "hostedCluster"
      transport:
        client: "kubernetes"
      manifest:
        ref: "/etc/adapter/hostedcluster.yaml"
      discovery:
        namespace: "clusters-{{ .clusterId }}"
        bySelectors:
          labelSelector:
            hyperfleet.io/cluster-id: "{{ .clusterId }}"
            hyperfleet.io/resource-type: "hosted-cluster"

  # ============================================================================
  # Phase 4: Status reporting
  # ============================================================================
  post:
    payloads:
      - name: "statusPayload"
        build:
          adapter: "{{ .metadata.name }}"
          conditions:
            # Applied: all prerequisite resources + HostedCluster created
            - type: "Applied"
              status:
                expression: |
                  has(resources.clusterNamespace) && has(resources.signingKeySecret) && has(resources.hostedCluster)
                  ? "True" : "False"
              reason:
                expression: |
                  has(resources.clusterNamespace) && has(resources.signingKeySecret) && has(resources.hostedCluster)
                  ? "ResourcesCreated" : "ResourcesNotCreated"
              message:
                expression: |
                  has(resources.clusterNamespace) && has(resources.signingKeySecret) && has(resources.hostedCluster)
                  ? "All resources created: Namespace, pull-secret, signing-key, Certificate, HostedCluster"
                  : "Waiting for resources to be created"

            # Available: HostedCluster Available condition
            - type: "Available"
              status:
                expression: |
                  resources.?hostedCluster.?status.?conditions.orValue([]).exists(c, c.type == "Available")
                  ? resources.hostedCluster.status.conditions.filter(c, c.type == "Available")[0].status
                  : "Unknown"
              reason:
                expression: |
                  resources.?hostedCluster.?status.?conditions.orValue([]).exists(c, c.type == "Available")
                  ? resources.hostedCluster.status.conditions.filter(c, c.type == "Available")[0].reason
                  : "ConditionNotFound"
              message:
                expression: |
                  resources.?hostedCluster.?status.?conditions.orValue([]).exists(c, c.type == "Available")
                  ? resources.hostedCluster.status.conditions.filter(c, c.type == "Available")[0].message
                  : "HostedCluster Available condition not yet reported"

            # Health: HostedCluster not degraded
            - type: "Health"
              status:
                expression: |
                  resources.?hostedCluster.?status.?conditions.orValue([]).exists(c, c.type == "Degraded")
                  ? (resources.hostedCluster.status.conditions.filter(c, c.type == "Degraded")[0].status == "False" ? "True" : "False")
                  : "Unknown"
              reason:
                expression: |
                  resources.?hostedCluster.?status.?conditions.orValue([]).exists(c, c.type == "Degraded")
                  ? (resources.hostedCluster.status.conditions.filter(c, c.type == "Degraded")[0].status == "False"
                      ? "NotDegraded"
                      : resources.hostedCluster.status.conditions.filter(c, c.type == "Degraded")[0].reason)
                  : "ConditionNotFound"
              message:
                expression: |
                  resources.?hostedCluster.?status.?conditions.orValue([]).exists(c, c.type == "Degraded")
                  ? (resources.hostedCluster.status.conditions.filter(c, c.type == "Degraded")[0].status == "False"
                      ? "HostedCluster is healthy"
                      : resources.hostedCluster.status.conditions.filter(c, c.type == "Degraded")[0].message)
                  : "Degraded condition not yet reported"

          observed_generation:
            expression: "generation"
          observed_time: "{{ now | date \"2006-01-02T15:04:05Z07:00\" }}"

          data:
            hostedCluster:
              name:
                expression: |
                  resources.?hostedCluster.?metadata.?name.orValue("")
              apiEndpoint:
                expression: |
                  resources.?hostedCluster.?status.?controlPlaneEndpoint.?host.orValue("") != ""
                  ? "https://" + resources.hostedCluster.status.controlPlaneEndpoint.host
                      + ":" + string(resources.hostedCluster.status.controlPlaneEndpoint.port)
                  : ""
              version:
                expression: |
                  resources.?hostedCluster.?status.?version.?history.orValue([]).size() > 0
                  ? resources.hostedCluster.status.version.history[0].version
                  : ""

    postActions:
      - name: "reportClusterStatus"
        apiCall:
          method: "POST"
          url: "/clusters/{{ .clusterId }}/statuses"
          headers:
            - name: "Content-Type"
              value: "application/json"
          body: "{{ .statusPayload }}"
